<module with_pydantic  # A small example with…
    <class with_pydantic.Foo  # !!! abstract "Usage …
        <method def __init__(self, /, **data: Any): ...  # inherited from pydantic.main.BaseModel.__init__, Create a new model b…>
        <var a: int = 1>
        <var b: int = 2  # Docstring for b.>
        <var model_config: ClassVar[pydantic.config.ConfigDict] = {}  # Configuration for th…>
        <method def model_fields(unknown): ...  # inherited from pydantic.main.BaseModel.model_fields, A decorator exposing…>
        <method def model_computed_fields(unknown): ...  # inherited from pydantic.main.BaseModel.model_computed_fields, A decorator exposing…>
        <var model_extra: dict[str, typing.Any] | None  # inherited from pydantic.main.BaseModel.model_extra, Get extra fields set…>
        <var model_fields_set: set[str]  # inherited from pydantic.main.BaseModel.model_fields_set, Returns the set of f…>
        <@classmethod class def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self: ...  # inherited from pydantic.main.BaseModel.model_construct, Creates a new instan…>
        <method def model_copy(
            self,
            *,
            update: Mapping[str, typing.Any] | None = None,
            deep: bool = False
        ) -> Self: ...  # inherited from pydantic.main.BaseModel.model_copy, !!! abstract "Usage …>
        <method def model_dump(
            self,
            *,
            mode: Union[Literal['json', 'python'], str] = 'python',
            include: Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], NoneType] = None,
            exclude: Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], NoneType] = None,
            context: typing.Any | None = None,
            by_alias: bool | None = None,
            exclude_unset: bool = False,
            exclude_defaults: bool = False,
            exclude_none: bool = False,
            exclude_computed_fields: bool = False,
            round_trip: bool = False,
            warnings: Union[bool, Literal['none', 'warn', 'error']] = True,
            fallback: Optional[Callable[[Any], Any]] = None,
            serialize_as_any: bool = False
        ) -> dict[str, typing.Any]: ...  # inherited from pydantic.main.BaseModel.model_dump, !!! abstract "Usage …>
        <method def model_dump_json(
            self,
            *,
            indent: int | None = None,
            ensure_ascii: bool = False,
            include: Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], NoneType] = None,
            exclude: Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], NoneType] = None,
            context: typing.Any | None = None,
            by_alias: bool | None = None,
            exclude_unset: bool = False,
            exclude_defaults: bool = False,
            exclude_none: bool = False,
            exclude_computed_fields: bool = False,
            round_trip: bool = False,
            warnings: Union[bool, Literal['none', 'warn', 'error']] = True,
            fallback: Optional[Callable[[Any], Any]] = None,
            serialize_as_any: bool = False
        ) -> str: ...  # inherited from pydantic.main.BaseModel.model_dump_json, !!! abstract "Usage …>
        <@classmethod class def model_json_schema(
            cls,
            by_alias: bool = True,
            ref_template: str = '#/$defs/{model}',
            schema_generator: type[pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>,
            mode: Literal['validation', 'serialization'] = 'validation',
            *,
            union_format: Literal['any_of', 'primitive_type_array'] = 'any_of'
        ) -> dict[str, typing.Any]: ...  # inherited from pydantic.main.BaseModel.model_json_schema, Generates a JSON sch…>
        <@classmethod class def model_parametrized_name(cls, params: tuple[type[typing.Any], ...]) -> str: ...  # inherited from pydantic.main.BaseModel.model_parametrized_name, Compute the class na…>
        <method def model_post_init(self, context: Any, /) -> None: ...  # inherited from pydantic.main.BaseModel.model_post_init, Override this method…>
        <@classmethod class def model_rebuild(
            cls,
            *,
            force: bool = False,
            raise_errors: bool = True,
            _parent_namespace_depth: int = 2,
            _types_namespace: Mapping[str, typing.Any] | None = None
        ) -> bool | None: ...  # inherited from pydantic.main.BaseModel.model_rebuild, Try to rebuild the p…>
        <@classmethod class def model_validate(
            cls,
            obj: Any,
            *,
            strict: bool | None = None,
            extra: Optional[Literal['allow', 'ignore', 'forbid']] = None,
            from_attributes: bool | None = None,
            context: typing.Any | None = None,
            by_alias: bool | None = None,
            by_name: bool | None = None
        ) -> Self: ...  # inherited from pydantic.main.BaseModel.model_validate, Validate a pydantic …>
        <@classmethod class def model_validate_json(
            cls,
            json_data: str | bytes | bytearray,
            *,
            strict: bool | None = None,
            extra: Optional[Literal['allow', 'ignore', 'forbid']] = None,
            context: typing.Any | None = None,
            by_alias: bool | None = None,
            by_name: bool | None = None
        ) -> Self: ...  # inherited from pydantic.main.BaseModel.model_validate_json, !!! abstract "Usage …>
        <@classmethod class def model_validate_strings(
            cls,
            obj: Any,
            *,
            strict: bool | None = None,
            extra: Optional[Literal['allow', 'ignore', 'forbid']] = None,
            context: typing.Any | None = None,
            by_alias: bool | None = None,
            by_name: bool | None = None
        ) -> Self: ...  # inherited from pydantic.main.BaseModel.model_validate_strings, Validate the given o…>
        <@typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None) method def dict(
            self,
            *,
            include: Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], NoneType] = None,
            exclude: Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], NoneType] = None,
            by_alias: bool = False,
            exclude_unset: bool = False,
            exclude_defaults: bool = False,
            exclude_none: bool = False
        ) -> Dict[str, Any]: ...  # inherited from pydantic.main.BaseModel.dict>
        <@typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None) method def json(
            self,
            *,
            include: Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], NoneType] = None,
            exclude: Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[ForwardRef('IncEx'), bool]], Mapping[str, Union[ForwardRef('IncEx'), bool]], bool]], NoneType] = None,
            by_alias: bool = False,
            exclude_unset: bool = False,
            exclude_defaults: bool = False,
            exclude_none: bool = False,
            encoder: Optional[Callable[[Any], Any]] = PydanticUndefined,
            models_as_dict: bool = PydanticUndefined,
            **dumps_kwargs: Any
        ) -> str: ...  # inherited from pydantic.main.BaseModel.json>
        <@classmethod @typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None) class def parse_obj(cls, obj: Any) -> Self: ...  # inherited from pydantic.main.BaseModel.parse_obj>
        <@classmethod @typing_extensions.deprecated('The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, otherwise load the data then use `model_validate` instead.', category=None) class def parse_raw(
            cls,
            b: str | bytes,
            *,
            content_type: str | None = None,
            encoding: str = 'utf8',
            proto: pydantic.deprecated.parse.Protocol | None = None,
            allow_pickle: bool = False
        ) -> Self: ...  # inherited from pydantic.main.BaseModel.parse_raw>
        <@classmethod @typing_extensions.deprecated('The `parse_file` method is deprecated; load the data from file, then if your data is JSON use `model_validate_json`, otherwise `model_validate` instead.', category=None) class def parse_file(
            cls,
            path: str | pathlib._local.Path,
            *,
            content_type: str | None = None,
            encoding: str = 'utf8',
            proto: pydantic.deprecated.parse.Protocol | None = None,
            allow_pickle: bool = False
        ) -> Self: ...  # inherited from pydantic.main.BaseModel.parse_file>
        <@classmethod @typing_extensions.deprecated("The `from_orm` method is deprecated; set `model_config['from_attributes']=True` and use `model_validate` instead.", category=None) class def from_orm(cls, obj: Any) -> Self: ...  # inherited from pydantic.main.BaseModel.from_orm>
        <@classmethod @typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None) class def construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self: ...  # inherited from pydantic.main.BaseModel.construct>
        <@typing_extensions.deprecated('The `copy` method is deprecated; use `model_copy` instead. See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.', category=None) method def copy(
            self,
            *,
            include: Set[int] | Set[str] | Mapping[int, typing.Any] | Mapping[str, typing.Any] | None = None,
            exclude: Set[int] | Set[str] | Mapping[int, typing.Any] | Mapping[str, typing.Any] | None = None,
            update: Optional[Dict[str, Any]] = None,
            deep: bool = False
        ) -> Self: ...  # inherited from pydantic.main.BaseModel.copy, Returns a copy of th…>
        <@classmethod @typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None) class def schema(
            cls,
            by_alias: bool = True,
            ref_template: str = '#/$defs/{model}'
        ) -> Dict[str, Any]: ...  # inherited from pydantic.main.BaseModel.schema>
        <@classmethod @typing_extensions.deprecated('The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.', category=None) class def schema_json(
            cls,
            *,
            by_alias: bool = True,
            ref_template: str = '#/$defs/{model}',
            **dumps_kwargs: Any
        ) -> str: ...  # inherited from pydantic.main.BaseModel.schema_json>
        <@classmethod @typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None) class def validate(cls, value: Any) -> Self: ...  # inherited from pydantic.main.BaseModel.validate>
        <@classmethod @typing_extensions.deprecated('The `update_forward_refs` method is deprecated; use `model_rebuild` instead.', category=None) class def update_forward_refs(cls, **localns: Any) -> None: ...  # inherited from pydantic.main.BaseModel.update_forward_refs>
    >
>